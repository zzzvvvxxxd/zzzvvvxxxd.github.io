<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>zzzvvvxxxd</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="zzzvvvxxxd">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="zzzvvvxxxd">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zzzvvvxxxd">
  
    <link rel="alternate" href="/atom.xml" title="zzzvvvxxxd" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zzzvvvxxxd</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">最快的外卖小哥</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2PC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/11/2PC/" class="article-date">
  <time datetime="2015-12-11T13:43:21.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/2PC/">【一致性协议01】 2PC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Two-Phase Commit,二阶段提交,作为最基础的一致性协议,保证了分布式系统数据的一致性.目前绝大多数的关系型数据库都是使用2PC来完成分布式事务处理的.<br>利用2PC协议能够非常方便地完成所有数据库事务参与者的协调,统一决定事务的提交或回滚,从而能有效地保证分布式数据一致性.  </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>原理简单，实现方便</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>同步阻塞</p>
<blockquote>
<p>极大的限制了系统的性能</p>
</blockquote>
</li>
<li><p>单点问题</p>
<blockquote>
<p>协调者在整个二阶段提交过程中，一旦出现故障（尤其是在阶段二），都会导致系统无法正常运行</p>
</blockquote>
</li>
<li><p>脑裂</p>
<blockquote>
<p>也就是数据不一致<br>在阶段二，即执行事务提交的阶段，当协调者向所有参与者发送commit请求之后，发生了局域网络异常或者是协调者在尚未发送完commit请求之前自身崩溃，导致只有部分的参与者接收到了commit请求，这部分参与者就会进行事务的提交，没有收到commit的参与者则无法进行事务的提交。于是，整个分布式系统出现数据不一致的情况。</p>
</blockquote>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h3><p>阶段1: 提交事务请求(投票阶段):</p>
<ol>
<li><p>事务询问.</p>
<blockquote>
<p>协调者向所有的参与者发送事务内容,询问是否可以执行事务提交操作,并开始等待各参与者的响应.  </p>
</blockquote>
</li>
<li><p>执行事务.</p>
<blockquote>
<p>各参与者节点执行事务操作,并将<code>Undo</code>和<code>Redo</code>信息记入事务日志.</p>
</blockquote>
</li>
<li><p>各参与者向协调者反馈事务询问的响应</p>
<blockquote>
<p>如果参与者成功执行了事务操作,那么就反馈给协调者<code>Yes</code>信息,表示事务可以执行; 如果参与者没有成功执行事务就反馈给协调者<code>No</code>响应,表示事务不可以执行.  </p>
</blockquote>
</li>
</ol>
<p>这个阶段可以看成一种投票阶段,即各个参与者投票表明是否要继续执行接下去的事务提交操作.  </p>
<p>阶段2: 执行事务提交<br>这个阶段,协调者会根据参与者的反馈情况来决定是否最终进行<code>commit</code>.一般,包含两种可能:  </p>
<h6 id="1-执行事务提交"><a href="#1-执行事务提交" class="headerlink" title="#1 执行事务提交:"></a>#1 执行事务提交:</h6><ol>
<li><p>发送提交请求</p>
<blockquote>
<p>假如协调者从所有的参与者获得的反馈都是<code>YES</code>,那么就执行提交操作,协调者向参与者发送<code>commit</code>请求</p>
</blockquote>
</li>
<li><p>事务提交</p>
<blockquote>
<p>参与者接受到<code>Commit</code>请求后,会正式执行事务提交操作,并在完成后释放整个事务执行期间所占用的资源</p>
</blockquote>
</li>
<li><p>反馈事务提交结果</p>
<blockquote>
<p>参与者在完成事务提交之后,向协调者发送<code>Ack</code>信息</p>
</blockquote>
</li>
<li><p>完成事务</p>
<blockquote>
<p>协调者收到所有参与者的<code>Ack</code>消息后,完成事务</p>
</blockquote>
</li>
</ol>
<h6 id="2-中断事务"><a href="#2-中断事务" class="headerlink" title="#2 中断事务:"></a>#2 中断事务:</h6><p>如果任何一个参与者返回了<code>No</code>信息，或者等待超时之后，协调者尚无法接受到所有的参与者反馈信息，就会中断事务。  </p>
<ol>
<li><p>发送回滚请求</p>
<blockquote>
<p>协调者向所有参与者发出Rollback请求</p>
</blockquote>
</li>
<li><p>事务回滚</p>
<blockquote>
<p>参与者接收到Rollback请求后，会利用其在阶段一种记录的Undo信息来执行回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。  </p>
</blockquote>
</li>
<li><p>反馈事务回滚结果</p>
<blockquote>
<p>参与者在完成事务回滚之后，向协调者发送<code>Ack</code>消息</p>
</blockquote>
</li>
<li><p>中断事务</p>
<blockquote>
<p>协调者收到所有参与者反馈的<code>Ack</code>消息之后，完成事务中断</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/11/2PC/" data-id="cj65v1lbs0000d7f9cb0p4oia" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/一致性协议/">一致性协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-zmalloc1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/14/zmalloc1/" class="article-date">
  <time datetime="2015-06-14T01:13:21.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/zmalloc1/">【Redis源码】zmalloc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/14/zmalloc1/" data-id="cj65v1ldn001od7f9vn2a3lft" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mt4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/14/mt4/" class="article-date">
  <time datetime="2015-06-14T01:13:21.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/mt4/">【Java多线程-4】volatile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存行    cache line</td>
<td>缓存中可以分配的最小存储单元，处理器填写缓存线时，回家在整个缓存线，需要使用多个内存读周期</td>
</tr>
<tr>
<td>缓存行填充    cache line fill</td>
<td>当处理器识别到从内存中读取操作是可缓存的，处理器读取整个缓存行到适当的缓存</td>
</tr>
<tr>
<td>缓存命中    cache hit</td>
<td>如果进行告诉缓存行填充操作的内存位置仍是下次处理器访问的位置，处理器从缓存中读取操作数，而不是内存</td>
</tr>
</tbody>
</table>
<pre><code class="Java">instance = <span class="keyword">new</span> Singleton();
</code></pre>
<p>其对应的汇编代码为：  </p>
<pre><code class="asm">0x01a3de1d: movb $0x0, 0x1104800(%esi);
0x01a3de24: lock addl $0x0, (%eps);
</code></pre>
<p><strong>lock前缀的指令在多核处理器会引发：</strong>将当前处理器缓存行的数据写回到系统内存, 这个写回内存的操作会使其他CPU中缓存了该内存地址的数据无效<br>为了优化速度，处理器不直接和内存通信，一般是将系统内存数据读取到本地内存（L1，L2或其他），但是操作并不保证何时写回到主存。如果是volatile变量，在写入时，回向处理器发送Lock指令这个变量所在的缓存行的数据会写回到系统内存。这里就有一个缓存一致性协议，每个处理器嗅探在总线上传播的数据来检查自己的缓存值是否过期。如果处理器发现自己缓存行对应的内存地址被修改，就会将当前的处理器缓存设置为无效状态。该处理器再一次对该缓存数据的操作，就会先从主存中读取。  </p>
<h2 id="volatile实现原则"><a href="#volatile实现原则" class="headerlink" title="volatile实现原则"></a>volatile实现原则</h2><ul>
<li>Lock前缀指令会引发处理器缓存写回到内存  </li>
<li>一个处理器的缓存回写到内存会使得其他处理的缓存无效  </li>
</ul>
<p>也就是：</p>
<blockquote>
<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中（本地内存就是上文中的当前处理器缓存）的共享变量（实际应当是volatile变量所在的缓存行）刷新到主内存。所以，很多时候一些非volatile变量的写操作发生在volatile变量之前修改，因为这里的刷新机制，所以也无意中实现了可见性（很多blog中的代码都有这个问题…所以没有拿到理想的输出，例如：<a href="http://blog.csdn.net/ns_code/article/details/17101369）" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/17101369）</a>  </p>
</blockquote>
<hr>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>volatile是Java提供的一种弱同步机制  </p>
<p>在Java1.2之前，Java内存模型总是从主存（即共享内存）中读取变量，也就是不同线程读取的是同一块内存。而后来随着JVM优化，在多线程环境下volatile关键字的作用越来越明显。<br>当前的JMM模型下，线程可以把变量保存在本地内存，而不是直接在主存中读写。<br>后果就是：  </p>
<blockquote>
<p>一个线程在主存中修改了变量的值,另一个线程还在使用其拷贝到寄存器中的值,数据就产生了不一致性.    </p>
</blockquote>
<p>volatile就指示JVM改变量是不稳定的，每次操作都要在内存读取。在多线程环境下，任何多任务共享的变量，都应该是volatile的。新值可以立即同步到主存（即共享内存）。 每次使用前，从主存刷新。在任何时刻，两个不同的线程总是看到某个成员变量的同一个值在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 说白了就是：<strong>禁止线程私有拷贝</strong>  </p>
<p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制</p>
<h1 id="综合来说："><a href="#综合来说：" class="headerlink" title="综合来说："></a>综合来说：</h1><ul>
<li>volatile 变量对所有线程是立即可见的,对 volatile 变量所有的写操作都能立即反应到其他线程之中 </li>
<li>也就是说volatile变量在各个线程中是一致的                                               </li>
<li>但是基于volatile的运算仍旧不算是线程安全的      </li>
</ul>
<blockquote>
<p>在遇到多个线程共享的变量时都加上volatile，但是不要将其看成是线程安全的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/14/mt4/" data-id="cj65v1ldk001md7f9uh96xway" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM笔记3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/12/JVM笔记3/" class="article-date">
  <time datetime="2015-06-12T03:44:53.000Z" itemprop="datePublished">2015-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/12/JVM笔记3/">【深入理解Java虚拟机3-笔记】GC算法和垃圾收集器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="1-标记回收算法"><a href="#1-标记回收算法" class="headerlink" title="1. 标记回收算法"></a>1. 标记回收算法</h2><ul>
<li>标记</li>
<li>回收</li>
</ul>
<blockquote>
<p>标记出所有需要回收的对象，在标记完成后  统一回收所有标记的对象</p>
</blockquote>
<p>不足：</p>
<ol>
<li>效率问题。标记和清楚两个过程效率都不高</li>
<li>空间问题。会产生大量内存碎片，导致后续要分配较大对象时，无法找到足够的内存而不得不提前触发垃圾收集动作。</li>
</ol>
<h2 id="2-复制算法-Copying"><a href="#2-复制算法-Copying" class="headerlink" title="2. 复制算法 Copying"></a>2. 复制算法 Copying</h2><p>为了解决效率问题，复制算法将可用内存按容量划分为大小相同的两块，每次只使用其中一块，当这一块内存用完，就将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。不需要考虑内存碎片的情况，只需要移动堆顶指针，按顺序分配内存即可，<strong>实现简单，运行高效</strong>。  </p>
<ul>
<li>Eden  </li>
<li>Survivor0  </li>
<li>Survivor1  </li>
</ul>
<p>HotSpot中默认的Eden和Survivor的比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%。当Survivor空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）。  </p>
<h2 id="3-标记-压缩算法-Mark-Compact"><a href="#3-标记-压缩算法-Mark-Compact" class="headerlink" title="3. 标记-压缩算法 Mark-Compact"></a>3. 标记-压缩算法 Mark-Compact</h2><p>适用于老年代。<br>标记过程和标记-清楚算法一致，后续让所有存活对象都向一端移动，然后直接清理掉端边界意外的内存。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="https://raw.githubusercontent.com/zzzvvvxxxd/Picture/master/hexo/gc-all.png" alt="总览">  </p>
<p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明可以搭配使用</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>最基本、发展历史最悠久的收集器。是一个单线程的收集器，它只会使用一个CPU或一条线程来完成垃圾收集的工作，同时还必须暂停其他的所有工作线程，知道收集结束。比较适合client模式下的客户端或者单核的场景。<br><img src="https://raw.githubusercontent.com/zzzvvvxxxd/Picture/master/hexo/serial.png" alt="Serial收集器">  </p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>本质就是Serial收集器的多线程版本<br><img src="https://raw.githubusercontent.com/zzzvvvxxxd/Picture/master/hexo/parnew.png" alt="ParNew收集器"><br>目前只有Serial和ParNew可以和老年代的CMS收集器配合工作，而后者目前是最多使用的收集器。自然ParNew也成了Server模式下首选的新生代收集器。<br>ParNew是使用<code>-XX:+UseConcMarkSweepGC</code>的默认新生代收集器，也可以通过<code>-XX:+UseParNewGC</code>来明确指定它。<br>如果要设置ParNew的线程数，可以使用<code>-XX:ParallelGCThreads</code>来限制。  </p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>使用复制算法的新生代收集器。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿，而Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量（Throughput）。前者可以有更好的响应时间和用户体验，而后者则可以高效率地利用CPU，尽快完成计算密集型任务。  </p>
<blockquote>
<p>吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。<br>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p>
</blockquote>
<p>相关参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-XX:MaxGCPauseMillis  # 设置最大垃圾收集时间</div><div class="line">-XX:GCTimeRatio   # 直接设置吞吐量，默认值为99，即为允许最多1%的GC时间</div><div class="line">-XX:+UseAdaptiveSizePolicy  # Parallel Scavenge支持自适应调节 P80</div></pre></td></tr></table></figure></p>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial收集器的老年代版本，使用标记-整理算法  </p>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Scavenge的老年代版本，使用多线程标记-整理算法</p>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p><img src="https://raw.githubusercontent.com/zzzvvvxxxd/Picture/master/hexo/cms.png" alt="CMS收集器"><br>是一个以获取最短停顿时间为目标的收集器，基于<code>标记-清除</code>算法。  </p>
<ul>
<li><p>初始标记（CMS initial mark）</p>
<blockquote>
<p>仅仅标记一下GC Roots能直接关联到的对象</p>
</blockquote>
</li>
<li><p>并发标记（CMS concurrent mark） –&gt; stop the world</p>
<blockquote>
<p>进行GC Roots Tracing过程</p>
</blockquote>
</li>
<li><p>重新标记（CMS remark）</p>
<blockquote>
<p>修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，停顿时间稍长于初始标记，远小于并发标记</p>
</blockquote>
</li>
<li><p>并发清除（CMS concurrent sweep） –&gt; stop the world</p>
</li>
</ul>
<p>明显缺点：  </p>
<h6 id="CMS收集器对CPU资源非常敏感"><a href="#CMS收集器对CPU资源非常敏感" class="headerlink" title="CMS收集器对CPU资源非常敏感"></a>CMS收集器对CPU资源非常敏感</h6><blockquote>
<p>其默认启动的收集线程数=(CPU数量+3)/4，在用户程序本来CPU负荷已经比较高的情况下，如果还要分出CPU资源用来运行垃圾收集器线程，会使得CPU负载加重。</p>
</blockquote>
<h6 id="CMS无法处理浮动垃圾-Floating-Garbage-，可能会导致Concurrent-ModeFailure失败而导致另一次Full-GC"><a href="#CMS无法处理浮动垃圾-Floating-Garbage-，可能会导致Concurrent-ModeFailure失败而导致另一次Full-GC" class="headerlink" title="CMS无法处理浮动垃圾(Floating Garbage)，可能会导致Concurrent ModeFailure失败而导致另一次Full GC"></a>CMS无法处理浮动垃圾(Floating Garbage)，可能会导致<code>Concurrent ModeFailure</code>失败而导致另一次Full GC</h6><blockquote>
<p>由于CMS收集器和用户线程并发运行，因此在收集过程中不断有新的垃圾产生，这些垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好等待下一次GC时再将其清理掉，这些垃圾就称为浮动垃圾。<br>CMS垃圾收集器不能像其他垃圾收集器那样等待年老代机会完全被填满之后再进行收集，需要预留一部分空间供并发收集时的使用，可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>来设置年老代空间达到多少的百分比时触发CMS进行垃圾收集，默认是68%。<br>如果在CMS运行期间，预留的内存无法满足程序需要，就会出现一次ConcurrentMode Failure失败，此时虚拟机将启动预备方案，使用Serial Old收集器重新进行年老代垃圾回收。</p>
</blockquote>
<h6 id="CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片"><a href="#CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片" class="headerlink" title="CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片"></a>CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片</h6><blockquote>
<p>如果无法找到一块足够大的连续内存存放对象时，将会触发因此Full GC。CMS提供一个开关参数<code>-XX:+UseCMSCompactAtFullCollection</code>，用于指定在Full GC之后进行内存整理，内存整理会使得垃圾收集停顿时间变长，CMS提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，用于设置在执行多少次不压缩的Full GC之后，跟着再来一次内存整理。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/12/JVM笔记3/" data-id="cj65v1lcg000bd7f9xjayu4pm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mt3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/11/mt3/" class="article-date">
  <time datetime="2015-06-11T03:29:08.000Z" itemprop="datePublished">2015-06-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/11/mt3/">【Java多线程-2】线程挂起、恢复、终止</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>类似suspend()方法的挂起方式，已经被java丢弃, 较为合理的方式是设置挂起的标识位   </p>
<p>首先在Runnable对象中设置标志位suspended  </p>
<pre><code class="Java"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> suspended;
</code></pre>
<p>volatile变量告诉JVM，这个变量将要被外部的线程修改，具体的参考下一篇笔记吧<br>然后设置置位和消除suspended状态方法   </p>
<pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendRequest</span><span class="params">()</span> </span>{  
    suspended = <span class="keyword">true</span>;  
}  

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeRequest</span><span class="params">()</span> </span>{  
    suspended = <span class="keyword">false</span>;  
}
</code></pre>
<p>还有一个挂起时用于等待的方法：   </p>
<pre><code class="Java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitWhileSuspended</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{  
    <span class="comment">//这是一个“繁忙等待”技术的示例。  </span>
    <span class="comment">//它是非等待条件改变的最佳途径，因为它会不断请求处理器周期地执行检查，   </span>
    <span class="comment">//更佳的技术是：使用Java的内置“通知-等待”机制  </span>
    <span class="keyword">while</span> ( suspended ) {  
        Thread.sleep(<span class="number">200</span>);  
    }  
}
</code></pre>
<p>接下来在Runnable对象的run()方法所要保护起来的代码段前后添加waitWhileSuspended方法来确保进入和退出代码块的时候，都可以检测到suspend信号，从而可以挂起</p>
<pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        waitWhileSuspended(); 

        <span class="comment">// do sth ...</span>
        waitWhileSuspended();
    }
}
</code></pre>
<p>而产生suspend信号的线程只需要在需要线程挂起的时候调用suspendRequest()方法,解除suspend怎使用resumeRequest()方法而Runnable对象中被waitWhileSuspended();包围的代码段不会被suspend信号终止</p>
<h1 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h1><p>在Thread的run()方法中return，线程会自然消亡  </p>
<p>如果使用stop()线程突然终止，很少有机会进行清理工作会释放当前所持有的锁，而锁的突然解除，会对数据一致性产生危险，甚至程序崩溃解决方案还是使用标志位,然后在程序中使用while来检测标志位</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/11/mt3/" data-id="cj65v1ldj001hd7f91hcnf0xt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mt2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/10/mt2/" class="article-date">
  <time datetime="2015-06-10T13:12:32.000Z" itemprop="datePublished">2015-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/10/mt2/">【Java多线程-1】中断线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><pre><code class="Java">Thread.interrupt()
</code></pre>
<p>当一个线程执行时，另一个线程可以调用Thread对象的interrupt()方法来中断它</p>
<h2 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt()方法"></a>interrupt()方法</h2><p>在目标线程中设置一个标志，表示它已经被中断。类似sleep这样的方法，会检查该标志位，如果被置位会抛出InterruptedException异常<br>目标线程可以catch到InterruptedException，但是并不会中断该线程try-catch之后的代码执行，如果catch语句块中没有类似return的语句，则会在catch之后继续顺序执行。  </p>
<h2 id="isInterrupted-方法"><a href="#isInterrupted-方法" class="headerlink" title="isInterrupted()方法"></a>isInterrupted()方法</h2><p>判断中断状态<br>可以在Thread对象上调用isInterrupted()方法来检查任何线程的中断状态。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>线程一旦被中断，isInterrupted（）方法便会返回true，而一旦sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回false。</p>
<pre><code class="Java"><span class="comment">// 中断该线程</span>
<span class="comment">// 除了是线程自己interrupt自己，否则都要使用checkAccess函数进行权限检查</span>
<span class="comment">// 可能会引起SecurityException()</span>
<span class="comment">// 如果线程被wait() join() sleep()函数阻塞住，那么其interrupt的状态会被清空</span>
<span class="comment">// 并且会抛出InterruptedException</span>
<span class="comment">// 如果线程被阻塞在InterruptibleChannel上的nio操作，那么该channel会被关闭</span>
<span class="comment">// 线程的interrupt状态会被置位，线程也会收到ClosedByInterruptException异常</span>
<span class="comment">// 如果线程在nio.channels.Selector上阻塞，则线程的interrupt状态会被置位</span>
<span class="comment">// 并且会从选定的操作中立即返回...</span>
<span class="comment">// 如果不是上述的情况，那么线程的interrupt状态将被设置</span>
<span class="comment">// 对非alive的线程，使用该方法，没有任何作用</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())
        checkAccess();
    <span class="keyword">synchronized</span> (blockerLock) {
        Interruptible b = blocker;
        <span class="keyword">if</span> (b != <span class="keyword">null</span>) {
            interrupt0();           <span class="comment">// Just to set the interrupt flag</span>
            b.interrupt(<span class="keyword">this</span>);
            <span class="keyword">return</span>;
        }
    }
    interrupt0();
}
</code></pre>
<h2 id="Thread-interrupted-方法判断中断状态"><a href="#Thread-interrupted-方法判断中断状态" class="headerlink" title="Thread.interrupted()方法判断中断状态"></a>Thread.interrupted()方法判断中断状态</h2><p>可以使用Thread.interrupted()方法来检查当前线程的中断状态（并隐式重置为false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。<br>与isInterrupted()不同，它将自动重置中断状态为false，第二次调用Thread.interrupted()方法，总是返回false，除非中断了线程。<br>建议使用isInterrupted()方法   </p>
<h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><pre><code class="Java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
              <span class="keyword">try</span>{
                     System.out.println(<span class="string">"in run() - sleep about 20s ..."</span>);
                     Thread.sleep(<span class="number">20000</span>);
                     System.out.println(<span class="string">"in run() - wake up!"</span>);
              } <span class="keyword">catch</span> (InterruptedException e) {
                     System.out.println(<span class="string">"in run() - interrupted while sleeping!"</span>);
                     <span class="keyword">return</span>;        <span class="comment">//返回run调用处</span>
              }
              System.out.println(<span class="string">"in run() - leaving normally"</span>);
       }

       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{
              ThreadTest r = <span class="keyword">new</span> ThreadTest();
              Thread t = <span class="keyword">new</span> Thread(r);
              t.start();
              Thread.sleep(<span class="number">2000</span>);
              System.out.println(<span class="string">"in main() - interrupting!"</span>);
              t.interrupt();
              System.out.println(<span class="string">"in main() - leaving"</span>);
       }
<span class="comment">// END_OF_CLASS</span>
}
</code></pre>
<p>输出：<br>run()方法sleep大于2s之后，被中断，并且立即返回<br>同样是2s被终端了try中的操作，但是继续顺序执行之后的代码，并不是立即返回   </p>
<h2 id="待决中断"><a href="#待决中断" class="headerlink" title="待决中断"></a>待决中断</h2><p>sleep()方法的实现检查到休眠线程被中断，它会相当友好地终止线程，并抛出InterruptedException异常。另外一种情况，如果线程在调用sleep()方法前被中断，那么该中断称为<strong>【待决中断】</strong><br>它会在遇到sleep())方法时，立即抛出InterruptedException异常。    </p>
<blockquote>
<p>我目前的理解就是，Thread.interrupt()只是改变了Thread内部的中断标识，不会终止程序的运行<br>当运行到sleep方法时，会检查中断标识，并抛出异常，然后就是用户处理的部分了</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/10/mt2/" data-id="cj65v1ldf001ad7f98i206dkg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM笔记2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/07/JVM笔记2/" class="article-date">
  <time datetime="2015-06-07T03:44:53.000Z" itemprop="datePublished">2015-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/07/JVM笔记2/">【深入理解Java虚拟机2-笔记】可达性分析&amp;引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>Java并没有使用传统的引用计数法，理由很简单，该算法无法很好的解决对象间相互循环引用的问题。  </p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>Java（甚至是C#和Lisp）的主流实现中，都是使用可达性分析（Reachability Chain）来判定对象是否存活的。</p>
<blockquote>
<p>基本思路：通过一系列的成为<code>GC Roots</code>的对象作为起点，从这些起点开始向下搜索，搜索过程的路径称为<code>Reference Chain</code>，当一个对象没有任何引用链相连时，则证明此对象是不可用的。所以即便有些对象相互引用，但是因为和<code>GC Roots</code>之间不可达，依然会被GC掉。  </p>
</blockquote>
<p>作为<code>GC Roots</code>的对象包括：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数法还是可达性分析来判断对象是否存活，都和“引用”相关。</p>
<ul>
<li><p>强引用（Strong Reference）</p>
<blockquote>
<p>类似<code>Object obj = new Object();</code>这类引用，只要强引用还在，GC就不会回收</p>
</blockquote>
</li>
<li><p>软引用（Soft Reference）</p>
<blockquote>
<p>用来描述一些还有用，但并非必须的对象。对于软引用关联的对象，在OOM之前，将会把这些对象进行二次回收。如果之后还是没有足够内存，就会跑出内存溢出异常。</p>
</blockquote>
</li>
<li><p>弱引用（Weak Reference）</p>
<blockquote>
<p>同样用来描述非必须对象，但是强度低于弱引用。在下一次GC时一定会被回收。</p>
</blockquote>
</li>
<li><p>虚引用（Phantom Reference）</p>
<blockquote>
<p>一个对象是否有虚引用，完全不会对其生存时间造成影响，也无法通过虚引用获得一个对象实例。唯一目的就是可以在这个对象呗收集器回收时收到一个系统通知。<br>一旦GC决定一个“obj”是虚可达的，它（指PhantomReference）将会被入队到对应的队列，但是它的指代并没有被清除。也就是说，虚引用的引用队列一定要明确地被一些应用程序代码所处理。<br>虚引用在实现一个对象被回收之前必须做清理操作是很有用的。有时候，他们比<code>finalize()</code>方法更灵活。</p>
</blockquote>
</li>
</ul>
<p>补充：</p>
<ol>
<li>软引用可以用来实现Caching和pooling</li>
<li><p>可以使用弱引用来实现对HashMap/HashSet中对象回收，但是要看使用场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Registry &#123;</div><div class="line">     private Set registeredObjects = new HashSet();</div><div class="line"></div><div class="line">     public void register(Object object) &#123;</div><div class="line">         registeredObjects.add( new WeakReference(object) ); //如果不适用WeakReference则HashSet中的对象永远不会回收</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>虚引用可以用来替代<code>finalize()</code>做一些回收之前的操作。例如，page缓存在gc之前需要被刷回磁盘。</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="external">1. Java 如何有效地避免OOM：善于利用软引用和弱引用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/07/JVM笔记2/" data-id="cj65v1lc80006d7f95rxry2la" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对象探秘" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/06/对象探秘/" class="article-date">
  <time datetime="2015-06-06T03:44:53.000Z" itemprop="datePublished">2015-06-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/06/对象探秘/">【深入理解Java虚拟机1-笔记】HotSpot对象探秘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h2><p>虚拟机遇到一个new指令时</p>
<ol>
<li>检查这个指令的参数是否能在常量池定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。</li>
<li>对新生对象分配内存<ol>
<li>内存是绝对规整的： <code>Bump the Pointer</code>指针碰撞。就是仅仅把内存分界指针挪动一段与对象大小相等的距离。</li>
<li>内存不是规整的： <code>Free List</code>通过空闲列表中找到足够大的空闲内存</li>
</ol>
</li>
<li>将分配到的内存空间初始化为0（不包括对象头）</li>
<li>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些都存储在对象头（Object Head）中</li>
</ol>
<h4 id="关于内存分配"><a href="#关于内存分配" class="headerlink" title="关于内存分配"></a>关于内存分配</h4><table>
<thead>
<tr>
<th>GC收集器</th>
<th>内存分配算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial、ParNew（带Compact过程的收集器）</td>
<td>指针碰撞</td>
</tr>
<tr>
<td>CMS（基于Mark-Sweep）</td>
<td>Free List</td>
</tr>
</tbody>
</table>
<p>问题：对象创建在虚拟机中是非常频繁的，即使是仅仅修改一个指针，在并发的情况下也不一定是安全的。<br>解决：  </p>
<ul>
<li>同步处理：CAS</li>
<li>将内存分配的操作划分在不同的空间中，即每个线程在Java堆中预先分配一小块内存，成为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB）</li>
</ul>
<p>虚拟机对TLAB使用<code>-XX:+/-UseTLAB</code>参数来配置</p>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><ul>
<li>对象头（Object Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zzzvvvxxxd/Picture/master/hexo/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt=""></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用，我们在Java程序中使用栈上的reference数据来操作堆上的具体对象。Java在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的具体位置，所以这是取决于虚拟机实现而定的。目前主流方式有两种：  </p>
<ul>
<li><p>句柄</p>
<blockquote>
<p>Java堆中将会划分中一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的地址信息。好处是移动对象时，只需要移动句柄，而不是reference。  </p>
</blockquote>
</li>
<li><p>直接指针</p>
<blockquote>
<p>堆中对象实例包含了类型数据的指针信息，reference中存储的就是对象实例地址。</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/06/对象探秘/" data-id="cj65v1lf3004qd7f9wku44jbl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM笔记0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/02/JVM笔记0/" class="article-date">
  <time datetime="2015-06-02T03:44:53.000Z" itemprop="datePublished">2015-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/02/JVM笔记0/">【深入理解Java虚拟机0-笔记】Java内存结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>方法区</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈（Native Method Stack）</li>
<li>程序计数器</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/02/JVM笔记0/" data-id="cj65v1lcc0009d7f9dpmgi6ch" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mt1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/29/mt1/" class="article-date">
  <time datetime="2015-05-28T23:56:29.000Z" itemprop="datePublished">2015-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/多线程系列/">多线程系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/29/mt1/">【Java多线程-0】综述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="并发编程的挑战："><a href="#并发编程的挑战：" class="headerlink" title="并发编程的挑战："></a>并发编程的挑战：</h2><ol>
<li>上下文切换<br> 可能出现并行程序性能不能最优化，甚至慢与串行程序  </li>
<li>死锁  </li>
<li>资源限制的挑战<br> 受限与资源的限制，可能将并行程序最终按照了串行方式执行（例如，某一资源同时只允许一个线程访问）  </li>
</ol>
<p>线程：<br>   程序中单独顺序的控制流，本身依靠程序进行运行<br>进程：<br>   执行中的程序  </p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>创建状态：new<br>就绪状态：调用了start()等待调度<br>运行状态：执行run()<br>阻塞状态：暂停执行，可能在等待IO<br>终止状态：线程销毁</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>1 :  MIN_PRIORITY<br>10:  MAX_PRIORITY<br>5 :  NORM_PRIORITY(默认)    </p>
<p>通过setPriority()方法设置  </p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>两种实现线程的方式   </p>
<ol>
<li>继承Thread类   </li>
<li>实现Runnable接口    </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    Run()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程调度器来分别调用所有线程的run()方法   </p>
<h2 id="Thread-常用方法"><a href="#Thread-常用方法" class="headerlink" title="Thread 常用方法"></a>Thread 常用方法</h2><pre><code class="Java"><span class="keyword">new</span> Thread()    <span class="comment">//创建</span>
<span class="keyword">new</span> Thread(String name)
<span class="keyword">new</span> Thread(Runnable target)
<span class="keyword">new</span> Thread(
    Runnable target,
    String name
)

<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>    <span class="comment">//启动线程</span>

<span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span>    <span class="comment">//线程休眠</span>
<span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(
    <span class="keyword">long</span> millis,
    <span class="keyword">int</span> nanos
)</span>

<span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>    <span class="comment">//使其他线程等待当前线程终止</span>
<span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>
<span class="keyword">void</span> <span class="title">join</span><span class="params">(
    <span class="keyword">long</span> millis,
    <span class="keyword">int</span> nanos
)</span>

stativ <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span>    <span class="comment">//当前运行线程释放处理器资源</span>
<span class="comment">//获取线程引用    </span>
<span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>    <span class="comment">//返回当前运行的线程引用</span>
<span class="comment">//是否启动</span>
<span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span>    <span class="comment">//是否启动</span>
<span class="comment">//优先级    </span>
<span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span>    <span class="comment">//设置线程优先级</span></span>
</code></pre>
<h2 id="继承Thread和实现Runnable接口的区别"><a href="#继承Thread和实现Runnable接口的区别" class="headerlink" title="继承Thread和实现Runnable接口的区别"></a>继承Thread和实现Runnable接口的区别</h2><h4 id="1-适合多个相同程序代码的线程去处理同一资源的情况"><a href="#1-适合多个相同程序代码的线程去处理同一资源的情况" class="headerlink" title="(1)适合多个相同程序代码的线程去处理同一资源的情况"></a>(1)适合多个相同程序代码的线程去处理同一资源的情况</h4><p>把虚拟CPU（线程）同程序的代码，数据有效的分离，较好地体现了面向对象的设计思想。   </p>
<h4 id="2-可以避免由于Java的单继承特性带来的局限。"><a href="#2-可以避免由于Java的单继承特性带来的局限。" class="headerlink" title="(2)可以避免由于Java的单继承特性带来的局限。"></a>(2)可以避免由于Java的单继承特性带来的局限。</h4><p>我们经常碰到这样一种情况，即当我们要将已经继承了某一个类的子类放入多线程中，由于一个类不能同时有两个父类，所以不能用继承Thread类的方式，那么，这个类就只能采用实现Runnable接口的方式了。     </p>
<h4 id="3-有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。"><a href="#3-有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。" class="headerlink" title="(3)有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。"></a>(3)有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。</h4><p>当多个线程的执行代码来自同一个类的实例时，即称它们共享相同的代码。多个线程操作相同的数据，与它们的代码无关。当共享访问相同的对象是，即它们共享相同的数据。当线程被构造时，需要的代码和数据通过一个对象作为构造函数实参传递进去，这个对象就是一个实现了Runnable接口的类的实例。    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/29/mt1/" data-id="cj65v1ldh001fd7f9tgnghrcb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/atomic/">atomic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程系列/">多线程系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日记/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔试/">笔试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/一致性协议/">一致性协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日记/">日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试/">笔试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试面试/">笔试面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 16px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/mysql/" style="font-size: 12px;">mysql</a> <a href="/tags/一致性协议/" style="font-size: 14px;">一致性协议</a> <a href="/tags/分布式/" style="font-size: 14px;">分布式</a> <a href="/tags/多线程/" style="font-size: 18px;">多线程</a> <a href="/tags/并发/" style="font-size: 18px;">并发</a> <a href="/tags/数据库/" style="font-size: 12px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 12px;">数据结构</a> <a href="/tags/日记/" style="font-size: 10px;">日记</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/笔试面试/" style="font-size: 10px;">笔试面试</a> <a href="/tags/算法/" style="font-size: 12px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/03/Future/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/08/22/ZAB2/">【一致性协议05】 ZAB协议详细介绍</a>
          </li>
        
          <li>
            <a href="/2016/08/20/Linux进程&线程命令/">【Linux命令】照看好咱们的进程和线程</a>
          </li>
        
          <li>
            <a href="/2016/08/09/ZAB/">【一致性协议04】 ZAB协议概述</a>
          </li>
        
          <li>
            <a href="/2016/08/08/Paxos/">【一致性协议03】 Paxos和分布式系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 zzzvvvxxxd<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>